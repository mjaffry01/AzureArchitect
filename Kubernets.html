<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kubernetes Mastery Coach</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root{--k8s:#326ce5;--ok:#16a34a;--bad:#dc2626}
    *{box-sizing:border-box}
    body{font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:#0b1220; color:#eaf0ff}
    header{background:linear-gradient(135deg,#1b2b57,#0b1220 60%); border-bottom:1px solid rgba(255,255,255,.08); padding:24px 16px; text-align:center; position:sticky; top:0; z-index:10}
    header h1{margin:.2rem 0; font-size:1.75rem}
    header p{margin:0; opacity:.8}
    main{padding:24px 18px; max-width:1100px; margin:0 auto}
    section{margin-bottom:28px}
    .card{background:#0e1730; border:1px solid rgba(255,255,255,.06); border-radius:14px; box-shadow:0 10px 20px rgba(0,0,0,.25)}
    .pad{padding:20px}
    .topics ul{display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:10px; list-style:none; padding-left:0; margin:0}
    .topics li{background:#0f1a38; border:1px solid rgba(255,255,255,.06); border-radius:10px; padding:10px 12px; opacity:.95}
    .controls{display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin:12px 0}
    .btn{background:var(--k8s); color:#fff; border:none; padding:.6rem .9rem; border-radius:10px; cursor:pointer; font-weight:600}
    .btn[disabled]{background:#4b5563; opacity:.6; cursor:not-allowed}
    .btn.mute{background:#0f1a38; border:1px solid rgba(255,255,255,.12)}
    .qbox{background:#0f1a38; border:1px solid rgba(255,255,255,.07); border-radius:12px; padding:16px; margin:12px 0}
    .qbox h4{margin:.1rem 0 .6rem}
    .opts{display:grid; gap:8px}
    .opt{background:#111d42; border:1px solid rgba(255,255,255,.08); color:#eaf0ff; padding:.55rem .7rem; border-radius:10px; cursor:pointer; text-align:left}
    .opt.correct{background:#062b16; border-color:#1db954}
    .opt.wrong{background:#2a0a0a; border-color:#ef4444}
    .status{font-size:.95rem; opacity:.9}
    .grid{display:grid; gap:16px; grid-template-columns:1fr;}
    @media(min-width:900px){.grid{grid-template-columns:2fr 1fr}}
    canvas{background:#0b1220; border:1px solid rgba(255,255,255,.06); border-radius:10px; padding:8px}
    .hint{font-size:.9rem; opacity:.8}
    .pill{display:inline-block; padding:.15rem .5rem; border-radius:999px; background:#13214a; border:1px solid rgba(255,255,255,.08); font-size:.75rem; margin-left:.4rem}
  </style>
</head>
<body>
  <header>
    <h1>Kubernetes Mastery Coach</h1>
    <p>Psychology‚Äëbacked learning ‚Ä¢ 5‚Äëquestion batches ‚Ä¢ Text‚Äëto‚Äëspeech ‚Ä¢ Progress graphs</p>
  </header>
  <main>
    <section class="card pad topics">
      <h2>üìö Topic Groups <span class="pill">spaced recall</span></h2>
      <ul>
        <li>Containers & Images</li>
        <li>Core Components (API Server, etcd, Scheduler, Controller)</li>
        <li>Pods & Scheduling</li>
        <li>Workloads (Deployment, StatefulSet, DaemonSet, Jobs)</li>
        <li>Init & Sidecar Containers</li>
        <li>Service Discovery & Load Balancing (Services, DNS, Ingress)</li>
        <li>Networking (CNI, NetworkPolicy)</li>
        <li>Scaling (HPA, VPA, Cluster Autoscaler)</li>
        <li>Storage (Volumes, PV, PVC, StorageClass, StatefulSets)</li>
        <li>Config & Secrets</li>
        <li>Security (RBAC, PSS, SecurityContext)</li>
        <li>Observability (Logs, Metrics, Tracing, Alerting)</li>
        <li>HA & DR (etcd, Backups, Multi‚Äëcluster)</li>
        <li>Service Mesh & API Gateway</li>
      </ul>
      <p class="hint">Tip: Review the topic list first to prime your brain (schema building), then jump into the quiz.</p>
    </section>

    <section class="card pad" id="quiz">
      <h2>üìù MCQ Practice <span class="pill">150 questions</span> <span class="pill">batch of 5</span></h2>
      <div class="controls">
        <button id="restart" class="btn">Restart Course</button>
        <button id="mute" class="btn mute" aria-pressed="false">üîä Voice: On</button>
        <button id="replay" class="btn mute">üîÅ Replay Voice</button>
        <button id="next" class="btn" disabled>Next 5</button>
        <span class="status" id="status">Batch 1 ‚Ä¢ 0/5 correct</span>
      </div>
      <div id="question-container"></div>
      <p class="hint">Rule: Only 5 questions show at a time. If you miss any, this same 5 will repeat until all 5 are correct.</p>
    </section>

    <section class="grid">
      <div class="card pad">
        <h3>üìä Mistakes by Topic</h3>
        <canvas id="byTopic"></canvas>
      </div>
      <div class="card pad">
        <h3>üìà Accuracy Over Time</h3>
        <canvas id="accuracy"></canvas>
      </div>
    </section>
  </main>

  <script>
    // ---------------------------
    // 150 MCQs ‚Äî grouped by topic
    // Each item: {t (topic), q (question), o (options), a (index of correct option)}
    // NOTE: Source data uses a=0 for all, but UI shuffles options so the correct
    // letter varies (A/B/C/D) on every render.
    // ---------------------------
    const Q = [
      // Containers & Images (10)
      {t:'Containers',q:'What is a container?',o:['A lightweight unit bundling app + dependencies','A full virtual machine','A physical server','A kernel module'],a:0},
      {t:'Containers',q:'Containers differ from VMs because they‚Ä¶',o:['Share the host OS kernel','Include their own kernels','Boot a guest OS per app','Require a hypervisor to run'],a:0},
      {t:'Containers',q:'Which command builds an image from a Dockerfile?',o:['docker build','docker run','docker start','docker image ls'],a:0},
      {t:'Containers',q:'An OCI image layer is best described as‚Ä¶',o:['A read-only filesystem diff','A running process','A kernel cgroup','A VM disk snapshot'],a:0},
      {t:'Containers',q:'Which is true about images?',o:['They are immutable once built','They always contain a full OS','They require root to run','They cannot be cached'],a:0},
      {t:'Containers',q:'Best practice for minimal images?',o:['Use distroless/alpine where possible','Always use ubuntu:latest','Include build tools in runtime','Disable health checks'],a:0},
      {t:'Containers',q:'What runs inside a Pod?',o:['One or more containers','Exactly one container','Exactly one VM','Only init processes'],a:0},
      {t:'Containers',q:'Container isolation mainly uses‚Ä¶',o:['Namespaces + cgroups','Hypervisor rings','PXE boot','TPM attestation'],a:0},
      {t:'Containers',q:'Where should app configuration generally live?',o:['Outside image (ConfigMap/ENV)','Baked into image','In kernel args','Only in code comments'],a:0},
      {t:'Containers',q:'Which registry term is correct?',o:['Image tag points to a digest','Digest points to a tag','Tag guarantees immutability','Registry is same as repository'],a:0},

      // Core Components (15)
      {t:'Core',q:'Smallest deployable unit in Kubernetes?',o:['Pod','Container','Node','Namespace'],a:0},
      {t:'Core',q:'Kubernetes persistent cluster state is stored in‚Ä¶',o:['etcd','API Server memory','Scheduler cache','Kubelet logs'],a:0},
      {t:'Core',q:'Which component schedules pods to nodes?',o:['kube-scheduler','kubelet','controller-manager','containerd'],a:0},
      {t:'Core',q:'Which serves as the front door for all requests?',o:['kube-apiserver','kube-proxy','coredns','metrics-server'],a:0},
      {t:'Core',q:'Controller Manager responsibility?',o:['Reconcile desired vs actual state','Run containers','Provide node metrics','Serve cluster DNS'],a:0},
      {t:'Core',q:'A Node is‚Ä¶',o:['A worker machine (VM/physical) that runs Pods','A single container','A CRD by default','Only master control plane'],a:0},
      {t:'Core',q:'Namespace is used to‚Ä¶',o:['Logically isolate resources','Provide physical isolation','Schedule pods','Encrypt secrets'],a:0},
      {t:'Core',q:'kubectl talks to which component?',o:['API Server','Scheduler','Kubelet','Controller Manager'],a:0},
      {t:'Core',q:'Desired state in K8s is defined by‚Ä¶',o:['Declarative manifests','Imperative node scripts','Binary etcd edits','Kernel boot flags'],a:0},
      {t:'Core',q:'What does kube-proxy do?',o:['Implements Service virtual IPs/routing','Schedules pods','Stores cluster state','Runs admission webhooks'],a:0},
      {t:'Core',q:'Cluster DNS is provided by‚Ä¶',o:['CoreDNS','kube-dns built-in to API','etcd resolver','cloud provider only'],a:0},
      {t:'Core',q:'Which object groups pods using labels for a stable IP?',o:['Service','Pod','Deployment','Ingress'],a:0},
      {t:'Core',q:'Label vs Annotation?',o:['Labels for selection; annotations for metadata','Both for selection','Both for human comments only','Annotations must be unique'],a:0},
      {t:'Core',q:'Which command shows cluster resources summary?',o:['kubectl get all','kubectl node list','kubectl apis','kubectl etcd dump'],a:0},
      {t:'Core',q:'Which field selector filters by metadata.name?',o:['metadata.name=my-pod','spec.name=my-pod','name:my-pod','filter=name:my-pod'],a:0},

      // Pods & Scheduling (10)
      {t:'Pods',q:'Pod phase ‚ÄúPending‚Äù means‚Ä¶',o:['Scheduled but images/containers not yet running','Terminated','Succeeded','Unknown'],a:0},
      {t:'Pods',q:'Affinity/anti-affinity are used to‚Ä¶',o:['Influence pod placement on nodes','Limit CPU/memory','Rotate secrets','Expose services'],a:0},
      {t:'Pods',q:'Taints and tolerations‚Ä¶',o:['Keep pods off certain nodes unless tolerated','Encrypt node traffic','Scale pods automatically','Provide pod DNS'],a:0},
      {t:'Pods',q:'Readiness probe indicates‚Ä¶',o:['When pod can receive traffic','If node is healthy','If image pulled','Cluster version'],a:0},
      {t:'Pods',q:'Liveness probe failing causes‚Ä¶',o:['Container restart','Evict node','Drop Service','Reschedule control plane'],a:0},
      {t:'Pods',q:'What is a Pod IP scope?',o:['Routable within cluster flat network','Public internet by default','Host-only always','Shared across namespaces'],a:0},
      {t:'Pods',q:'How to exec into running container?',o:['kubectl exec -it pod -- bash','kubectl ssh pod','kubectl attach --root','kubectl kubelet shell'],a:0},
      {t:'Pods',q:'Init containers run‚Ä¶',o:['Before app containers and must succeed','Alongside forever','After main container exits','Only on master nodes'],a:0},
      {t:'Pods',q:'Sidecar containers provide‚Ä¶',o:['Auxiliary features (proxy/logging)','Cluster DNS','Image builds','Node provisioning'],a:0},
      {t:'Pods',q:'Pod resource requests are used for‚Ä¶',o:['Scheduler placement decisions','Billing tags','Network policies','kubectl contexts'],a:0},

      // Workloads (20)
      {t:'Workloads',q:'Deployment is best for‚Ä¶',o:['Stateless apps','Databases needing identity','Per-node agents','Cluster DNS'],a:0},
      {t:'Workloads',q:'StatefulSet guarantees‚Ä¶',o:['Stable network IDs and storage per pod','One pod per node','Blue/green by default','GPU scheduling'],a:0},
      {t:'Workloads',q:'DaemonSet ensures‚Ä¶',o:['One pod per node','Zero-downtime updates','Sticky sessions','Init-only workloads'],a:0},
      {t:'Workloads',q:'Job object runs‚Ä¶',o:['Finite tasks to completion','Long-running services','Ingress controllers','Node upgrades'],a:0},
      {t:'Workloads',q:'CronJob schedules‚Ä¶',o:['Jobs on a time schedule','Deployments at boot','Node rotations','Rolling upgrades'],a:0},
      {t:'Workloads',q:'RollingUpdate on a Deployment‚Ä¶',o:['Gradually replaces pods','Stops all then starts all','Requires downtime','Is same as blue/green'],a:0},
      {t:'Workloads',q:'Recreate strategy does‚Ä¶',o:['Terminate all then create new','Canary traffic split','No pod restarts','Guaranteed zero downtime'],a:0},
      {t:'Workloads',q:'Which enables easy rollback?',o:['Deployment revision history','Direct etcd edits','Node reboot','kubectl label prune'],a:0},
      {t:'Workloads',q:'PodDisruptionBudget (PDB) ensures‚Ä¶',o:['Minimum available during voluntary disruptions','No evictions ever','Faster scaling','Ingress TLS'],a:0},
      {t:'Workloads',q:'HPA scales based on‚Ä¶',o:['Observed metrics (CPU/memory/custom)','YAML comments','Dockerfile size','Kubelet version'],a:0},
      {t:'Workloads',q:'Which object owns ReplicaSets?',o:['Deployment','Service','Ingress','DaemonSet'],a:0},
      {t:'Workloads',q:'MaxSurge/MaxUnavailable control‚Ä¶',o:['RollingUpdate parallelism','Network policy rules','Pod DNS','Volume mount paths'],a:0},
      {t:'Workloads',q:'Set image on a Deployment via‚Ä¶',o:['kubectl set image','kubectl set volume','kubectl set cluster','kubectl set probe'],a:0},
      {t:'Workloads',q:'For Kafka/ZooKeeper use‚Ä¶',o:['StatefulSet','Deployment','DaemonSet','CronJob'],a:0},
      {t:'Workloads',q:'NodeSelector selects‚Ä¶',o:['Nodes with matching labels','Pods by label','Namespaces','Services'],a:0},
      {t:'Workloads',q:'PriorityClass affects‚Ä¶',o:['Scheduling/eviction priority','Service IP','DNS TTL','Ingress path'],a:0},
      {t:'Workloads',q:'Which runs one-time DB migration?',o:['Job','DaemonSet','Service','ConfigMap'],a:0},
      {t:'Workloads',q:'Ensure agent on every node?',o:['DaemonSet','Deployment','StatefulSet','Job'],a:0},
      {t:'Workloads',q:'Sticky identity pod names look like‚Ä¶',o:['app-0, app-1, app-2','app-a, app-b','hash-only','node-uid'],a:0},
      {t:'Workloads',q:'CronJob schedule format is‚Ä¶',o:['Cron expression','ISO8601 duration','RFC3339 timestamp','Epoch seconds only'],a:0},

      // Config & Secrets (10)
      {t:'Config',q:'ConfigMaps store‚Ä¶',o:['Non-sensitive config','Passwords','TLS private keys','Container images'],a:0},
      {t:'Config',q:'Secrets are‚Ä¶',o:['Base64-encoded objects for sensitive data','Always encrypted at rest by default','Only for TLS','World-readable'],a:0},
      {t:'Config',q:'Mount a Secret into a Pod as‚Ä¶',o:['Env vars or files','Kernel module','Service','Ingress rule'],a:0},
      {t:'Config',q:'External secret managers are‚Ä¶',o:['Vault/AWS Secrets Manager/AKV','CoreDNS','kube-proxy','scheduler extenders'],a:0},
      {t:'Config',q:'Recommended: encrypt secrets at rest in‚Ä¶',o:['etcd','Containerd','CoreDNS','Kube-proxy'],a:0},
      {t:'Config',q:'Change config without rebuilding image by‚Ä¶',o:['Using ConfigMap','Editing Dockerfile','Changing kernel args','Re-tagging image'],a:0},
      {t:'Config',q:'Which controls access to resources?',o:['RBAC','CNI','PDB','PSS'],a:0},
      {t:'Config',q:'Downward API exposes‚Ä¶',o:['Pod/Container metadata as env/files','External internet','Cloud IAM','Node BIOS'],a:0},
      {t:'Config',q:'Projected volumes can‚Ä¶',o:['Combine multiple sources (Secret/CM/Downward API)','Resize PVs dynamically','Open NodePort','Run Jobs on schedule'],a:0},
      {t:'Config',q:'Immutable ConfigMap helps‚Ä¶',o:['Prevent accidental changes in prod','Auto‚Äëscaling','Ingress auth','Service type change'],a:0},

      // Networking (20)
      {t:'Networking',q:'Flat pod network means‚Ä¶',o:['Pods reachable across nodes without NAT','Pods can‚Äôt talk across nodes','Public exposure by default','Overlay always required'],a:0},
      {t:'Networking',q:'Service type for internal stable IP?',o:['ClusterIP','NodePort','LoadBalancer','ExternalName'],a:0},
      {t:'Networking',q:'Expose service outside cluster on each node port?',o:['NodePort','ClusterIP','Headless','None'],a:0},
      {t:'Networking',q:'Cloud LB integration uses Service type‚Ä¶',o:['LoadBalancer','ClusterIP','NodePort only','Ingress'],a:0},
      {t:'Networking',q:'Ingress provides‚Ä¶',o:['HTTP/S routing into cluster','Pod scheduling','Secret storage','PV management'],a:0},
      {t:'Networking',q:'CoreDNS provides‚Ä¶',o:['Service/Pod name resolution','Ingress TLS','Metrics scraping','Node autoscale'],a:0},
      {t:'Networking',q:'Headless Service (clusterIP: None)‚Ä¶',o:['Returns pod IPs via DNS without VIP','Blocks DNS','Creates LB automatically','Required for NodePort'],a:0},
      {t:'Networking',q:'NetworkPolicy controls‚Ä¶',o:['Allowed traffic between pods/namespaces','RBAC permissions','PV sizes','Node health'],a:0},
      {t:'Networking',q:'CNI plugins include‚Ä¶',o:['Calico, Cilium, Flannel','Prometheus, Grafana','Envoy, Nginx','Helm, Kustomize'],a:0},
      {t:'Networking',q:'Default if no NetworkPolicy?',o:['All traffic allowed','All denied','Only egress allowed','Only ingress allowed'],a:0},
      {t:'Networking',q:'TLS termination often happens at‚Ä¶',o:['Ingress controller','kubelet','etcd','CoreDNS'],a:0},
      {t:'Networking',q:'Service discovery within cluster commonly uses‚Ä¶',o:['DNS names','Static IPs','Hosts file','Manual registry'],a:0},
      {t:'Networking',q:'Service mesh sidecars commonly use‚Ä¶',o:['Envoy proxy','HAProxy only','NAT tables only','Side‚Äëkernel'],a:0},
      {t:'Networking',q:'kube-proxy modes:',o:['iptables or IPVS','BPF only','NAT only','ebtables mandatory'],a:0},
      {t:'Networking',q:'Ingress resource requires‚Ä¶',o:['An Ingress Controller implementation','Prometheus Operator','etcd gateway','DaemonSet on masters'],a:0},
      {t:'Networking',q:'ExternalName service maps to‚Ä¶',o:['External DNS name','Node IP','Pod CIDR','Ingress path only'],a:0},
      {t:'Networking',q:'Sticky sessions at Service level commonly via‚Ä¶',o:['sessionAffinity: ClientIP','headless service','taints','nodeSelector'],a:0},
      {t:'Networking',q:'mTLS between services is a feature of‚Ä¶',o:['Service Mesh','CoreDNS','kubelet','StorageClass'],a:0},
      {t:'Networking',q:'Path‚Äëbased routing configured on‚Ä¶',o:['Ingress rules','Service selectors','Pod labels only','ConfigMap only'],a:0},
      {t:'Networking',q:'Which object gives stable DNS + LB to pods?',o:['Service','Deployment','Job','Secret'],a:0},

      // Storage (15)
      {t:'Storage',q:'Volumes in a pod survive‚Ä¶',o:['Container restarts within same pod','Pod deletion','Cluster wipe','Node format'],a:0},
      {t:'Storage',q:'PV stands for‚Ä¶',o:['PersistentVolume','PodVolume','ProvisionedVolume','ProjectedVolume'],a:0},
      {t:'Storage',q:'PVC is‚Ä¶',o:['A request for storage by a pod','A volume type','A scheduler plugin','Ingress rule'],a:0},
      {t:'Storage',q:'StorageClass enables‚Ä¶',o:['Dynamic provisioning of PVs','DNS routing','RBAC roles','Ingress TLS'],a:0},
      {t:'Storage',q:'StatefulSet volume binding‚Ä¶',o:['One PV per replica (stable)','Shared PV among all','Ephemeral only','Not supported'],a:0},
      {t:'Storage',q:'Resize PVC typically requires‚Ä¶',o:['StorageClass/driver support','Reboot node','Change Service type','Edit kube-proxy'],a:0},
      {t:'Storage',q:'AccessModes example:',o:['ReadWriteOnce/ReadOnlyMany/ReadWriteMany','TCP/UDP','Ingress/egress','Allow/Deny'],a:0},
      {t:'Storage',q:'emptyDir volume lifecycle:',o:['Lives for pod lifetime','Persists after pod deletion','Node‚Äëscoped forever','Read‚Äëonly always'],a:0},
      {t:'Storage',q:'hostPath cautions:',o:['Couples pod to node path','Encrypted at rest by default','Is portable across clouds','Always recommended'],a:0},
      {t:'Storage',q:'Backup persistent data using‚Ä¶',o:['Snapshots/Velero/Cloud backups','kubectl logs','NetworkPolicy','kube-proxy'],a:0},
      {t:'Storage',q:'CSI stands for‚Ä¶',o:['Container Storage Interface','Cluster Storage Instance','Cloud Storage Integration','Config Storage Item'],a:0},
      {t:'Storage',q:'Which object binds PVC to PV?',o:['Controller reconciler','Scheduler','Ingress','CoreDNS'],a:0},
      {t:'Storage',q:'For databases, prefer‚Ä¶',o:['StatefulSet + dedicated PVC','Deployment + emptyDir','DaemonSet + CM','Job + Secret'],a:0},
      {t:'Storage',q:'Retain vs Delete reclaim policy affects‚Ä¶',o:['PV lifecycle after PVC release','Pod restart policy','Ingress class','RBAC verbs'],a:0},
      {t:'Storage',q:'Mount Secret files appear‚Ä¶',o:['As tmpfs within pod','On host root','In CoreDNS','In kube-proxy'],a:0},

      // Scaling (10)
      {t:'Scaling',q:'Horizontal scaling means‚Ä¶',o:['More pod replicas','More CPU to one pod','More nodes only','Bigger PVC'],a:0},
      {t:'Scaling',q:'Vertical scaling means‚Ä¶',o:['Adjust CPU/memory of a pod','More replicas','More clusters','More namespaces'],a:0},
      {t:'Scaling',q:'Cluster Autoscaler changes‚Ä¶',o:['Node count in cluster','Pod image','Service type','Ingress class'],a:0},
      {t:'Scaling',q:'HPA needs metrics from‚Ä¶',o:['metrics-server or custom metrics','CoreDNS','etcd only','kube-proxy'],a:0},
      {t:'Scaling',q:'Good HPA target utilization is‚Ä¶',o:['Workload dependent (tuned)','Always 80% CPU','Always 50% CPU','Fixed by cluster'],a:0},
      {t:'Scaling',q:'VPA primarily adjusts‚Ä¶',o:['Requests/limits of pods','Replica counts','Node counts','Ingress rules'],a:0},
      {t:'Scaling',q:'Burst traffic best handled by‚Ä¶',o:['HPA + Cluster Autoscaler','Only VPA','Only NodePort','Only annotations'],a:0},
      {t:'Scaling',q:'For stateful DBs, scaling often requires‚Ä¶',o:['Manual planning & shards/replica sets','Only HPA','Only VPA','Only DaemonSet'],a:0},
      {t:'Scaling',q:'HPA scales which object commonly?',o:['Deployments/ReplicaSets/StatefulSets','Services','Namespaces','Secrets'],a:0},
      {t:'Scaling',q:'Throttle flapping by‚Ä¶',o:['HPA stabilization windows/cooldowns','Disabling metrics','Using headless services','Forcing VMs'],a:0},

      // Security (15)
      {t:'Security',q:'RBAC controls‚Ä¶',o:['Who can do what via API','Pod IP routing','Ingress paths','PV size'],a:0},
      {t:'Security',q:'SecurityContext can‚Ä¶',o:['Drop Linux capabilities, set UID/GID','Create PVs','Assign NodePort','Scale pods'],a:0},
      {t:'Security',q:'Run container as root?',o:['Avoid when possible; use runAsUser','Always required','Only in DaemonSets','Never allowed'],a:0},
      {t:'Security',q:'Pod Security Standards (PSS) replace‚Ä¶',o:['PodSecurityPolicy (PSP)','RBAC','CNI','CSI'],a:0},
      {t:'Security',q:'NetworkPolicy provides‚Ä¶',o:['L3/L4 traffic rules between pods','TLS cert rotation','Audit logging','PV quotas'],a:0},
      {t:'Security',q:'Image security best practice:',o:['Scan & sign images; pin digests','Always :latest','Disable liveness probes','Use root SSH'],a:0},
      {t:'Security',q:'Secret at rest encryption is configured on‚Ä¶',o:['API server / etcd encryption providers','CoreDNS','Scheduler','kube-proxy'],a:0},
      {t:'Security',q:'ServiceAccount used for‚Ä¶',o:['In-cluster identity for pods','Node login','Ingress auth only','Docker login'],a:0},
      {t:'Security',q:'Admission controllers can‚Ä¶',o:['Validate/mutate requests','Schedule nodes','Store metrics','Do DNS'],a:0},
      {t:'Security',q:'Least privilege means‚Ä¶',o:['Minimal permissions needed','Cluster‚Äëadmin for devs','Wide open egress','Root everywhere'],a:0},
      {t:'Security',q:'psp replacement enforcement via‚Ä¶',o:['Namespace labels & PSS levels','HostPath bans only','IngressClass','Node taints only'],a:0},
      {t:'Security',q:'ImagePullSecrets used for‚Ä¶',o:['Private registries auth','Encrypt etcd','Expose Service','Scale Deployment'],a:0},
      {t:'Security',q:'Host networking risks‚Ä¶',o:['Bypasses pod isolation boundaries','Forces HPA','Blocks DNS','Deletes PVs'],a:0},
      {t:'Security',q:'Rootless containers help by‚Ä¶',o:['Reducing privilege escalation risk','Speeding DNS','Creating PVs','Changing Ingress'],a:0},
      {t:'Security',q:'Secrets mounted as env vars risk‚Ä¶',o:['Exposure in process lists/core dumps','Auto‚Äërotation','HPA issues','Ingress loops'],a:0},

      // Observability (10)
      {t:'Observability',q:'kubectl logs reads‚Ä¶',o:['Container stdout/stderr','etcd keys','CoreDNS cache','Ingress files'],a:0},
      {t:'Observability',q:'Prometheus primarily‚Ä¶',o:['Scrapes & stores metrics','Collects logs','Does tracing','Provisions PVs'],a:0},
      {t:'Observability',q:'Grafana is used to‚Ä¶',o:['Visualize dashboards','Run kube-proxy','Rotate TLS','Scale nodes'],a:0},
      {t:'Observability',q:'Jaeger provides‚Ä¶',o:['Distributed tracing','Central logs','DNS','Patching'],a:0},
      {t:'Observability',q:'Alertmanager‚Ä¶',o:['Routes/promotes alerts','Provides DNS','Schedules pods','Stores secrets'],a:0},
      {t:'Observability',q:'EFK stack stands for‚Ä¶',o:['Elasticsearch Fluentd Kibana','Envoy Flannel Kubelet','Etcd Flannel Kube‚Äëdns','Elixir Fiber Kustomize'],a:0},
      {t:'Observability',q:'cAdvisor/kubelet expose‚Ä¶',o:['Container/node metrics','Ingress rules','RBAC grants','PV quotas'],a:0},
      {t:'Observability',q:'Logs should be‚Ä¶',o:['Centralized & retained','Kept only on pod','Stored in etcd','Disabled in prod'],a:0},
      {t:'Observability',q:'Tracing helps with‚Ä¶',o:['Following a request across services','Node scaling','PVC binding','DNS TTL'],a:0},
      {t:'Observability',q:'Blackbox probing checks‚Ä¶',o:['External availability','PV IOPS','RBAC drift','CRD schemas'],a:0},

      // HA & DR (5)
      {t:'HA/DR',q:'etcd backups are critical because‚Ä¶',o:['They store cluster state','They store container images','They store logs','They run Ingress'],a:0},
      {t:'HA/DR',q:'Multi‚Äëmaster control plane gives‚Ä¶',o:['High availability','More GPU','More PVCs','Faster DNS'],a:0},
      {t:'HA/DR',q:'Velero commonly used for‚Ä¶',o:['Backups & restores','HPA tuning','Ingress routing','RBAC edits'],a:0},
      {t:'HA/DR',q:'Disaster recovery should be‚Ä¶',o:['Tested regularly (chaos/fire‚Äëdrills)','Documented only','Skipped to save cost','Done ad‚Äëhoc'],a:0},
      {t:'HA/DR',q:'Cluster Autoscaler during DR‚Ä¶',o:['Can re‚Äëadd nodes as capacity returns','Backs up etcd','Routes DNS','Creates CRDs'],a:0},

      // Service Mesh & API Gateway (10)
      {t:'Service Mesh',q:'Service mesh adds‚Ä¶',o:['mTLS, traffic control, observability','PV provisioning','Kubelet upgrades','DNS authoring'],a:0},
      {t:'Service Mesh',q:'Common sidecar proxy is‚Ä¶',o:['Envoy','Nginx Unit','Apache','Squid only'],a:0},
      {t:'Service Mesh',q:'Trade‚Äëoff of mesh is‚Ä¶',o:['Complexity & overhead','No TLS possible','No retries allowed','Removes Services'],a:0},
      {t:'Service Mesh',q:'API Gateway vs Ingress?',o:['Gateway is broader policy/edge; Ingress is K8s resource','They are identical','Ingress replaces Services','Gateway only for TCP'],a:0},
      {t:'Service Mesh',q:'Linkerd is known for‚Ä¶',o:['Simplicity/lightweight','Only tracing','Only storage','Only logs'],a:0},
      {t:'Service Mesh',q:'Canary releases are facilitated by‚Ä¶',o:['Traffic splitting in mesh/Ingress','PV snapshots','RBAC roles','CronJobs'],a:0},
      {t:'Service Mesh',q:'mTLS provides‚Ä¶',o:['Mutual authentication + encryption','Pod scheduling','PVC resize','CoreDNS caching'],a:0},
      {t:'Service Mesh',q:'Circuit breaking helps‚Ä¶',o:['Prevent cascading failures','Speed DNS','Allocate PVs','Scale nodes'],a:0},
      {t:'Service Mesh',q:'Sidecar pattern means‚Ä¶',o:['Helper container in same Pod','Daemon per node','CRD only','VM agent'],a:0},
      {t:'Service Mesh',q:'When to avoid mesh?',o:['Small/simple systems','Any prod system','If using RBAC','If using DNS'],a:0},
    ];

    // ---------------------------
    // Quiz state & logic (5-question batches with repeat-until-perfect)
    // ---------------------------
    const BATCH_SIZE = 5;
    let batchStart = 0;            // index into Q
    let answered = 0;              // answers given in current batch
    let correctThisBatch = 0;      // correct count in current batch
    let mistakesByTopic = {};      // {topic: count}
    let accuracyHistory = [];      // % per batch attempt
    let isMuted = false;           // TTS toggle
    let answeredStates = [];       // boolean per question in current batch
    let currentVoiceIdxInBatch = 0; // which question the TTS will read next

    const elContainer = document.getElementById('question-container');
    const elNext = document.getElementById('next');
    const elStatus = document.getElementById('status');
    const elMute = document.getElementById('mute');
    const elReplay = document.getElementById('replay');
    const elRestart = document.getElementById('restart');

    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }

    function currentBatch(){
      return Q.slice(batchStart, Math.min(batchStart + BATCH_SIZE, Q.length));
    }

    function renderBatch(){
      elContainer.innerHTML = '';
      answered = 0; correctThisBatch = 0; elNext.disabled = true;
      const batch = currentBatch();
      // reset per-batch voice progress
      answeredStates = new Array(batch.length).fill(false);
      currentVoiceIdxInBatch = 0;

      batch.forEach((q, idx) => {
        const box = document.createElement('div');
        box.className = 'qbox';
        box.innerHTML = `<h4>Q${batchStart + idx + 1}: ${q.q} <span class="pill">${q.t}</span></h4>`;
        const optsWrap = document.createElement('div');
        optsWrap.className = 'opts';

        // NEW: shuffle options per render & track correct index for THIS render
        const indices = shuffle([0,1,2,3]);
        const correctLocalIndex = indices.findIndex(i => i === q.a);
        optsWrap.dataset.correctIndex = String(correctLocalIndex);

        indices.forEach((origIdx, displayIdx) => {
          const btn = document.createElement('button');
          btn.className = 'opt';
          const letter = 'ABCD'[displayIdx];
          btn.textContent = `${letter}. ${q.o[origIdx]}`;
          btn.addEventListener('click', () => handleAnswer(q, displayIdx, btn, optsWrap, idx));
          optsWrap.appendChild(btn);
        });

        box.appendChild(optsWrap);
        elContainer.appendChild(box);
      });
      updateStatus();
      // Speak only the current question (no options)
      speakQuestionAt(currentVoiceIdxInBatch);
    }

    function handleAnswer(q, choice, btn, optsWrap, idx){
      // disable all options for this question after one pick
      Array.from(optsWrap.children).forEach(b=>b.disabled=true);
      answered++;

      const correctIndex = Number(optsWrap.dataset.correctIndex);
      if(choice === correctIndex){
        btn.classList.add('correct');
        correctThisBatch++;
      } else {
        btn.classList.add('wrong');
        // mark correct one for learning (for THIS render)
        const correctBtn = Array.from(optsWrap.children)[correctIndex];
        if(correctBtn) correctBtn.classList.add('correct');
        mistakesByTopic[q.t] = (mistakesByTopic[q.t]||0)+1;
        updateByTopicChart();
      }
      updateStatus();

      // Mark this question as answered for voice progression
      answeredStates[idx] = true;
      // After answering, speak the next unanswered question (if any)
      const nextIdx = nextUnansweredIndex();
      if(nextIdx !== -1){
        currentVoiceIdxInBatch = nextIdx;
        speakQuestionAt(currentVoiceIdxInBatch);
      }

      if(answered === currentBatch().length){
        // evaluate batch
        const pct = Math.round((correctThisBatch/answered)*100);
        accuracyHistory.push(pct);
        updateAccuracyChart();
        if(correctThisBatch === BATCH_SIZE){
          // perfect -> unlock next 5
          elNext.disabled = false;
        } else {
          // repeat same 5 (reshuffle options each time for learning)
          setTimeout(()=>{ renderBatch(); }, 600);
        }
      }
    }

    function updateStatus(){
      const batchNum = Math.floor(batchStart/BATCH_SIZE)+1;
      elStatus.textContent = `Batch ${batchNum} ‚Ä¢ ${correctThisBatch}/${Math.min(BATCH_SIZE, Q.length-batchStart)} correct`;
    }

    elNext.addEventListener('click', ()=>{
      batchStart += BATCH_SIZE;
      if(batchStart >= Q.length){
        batchStart = Q.length - BATCH_SIZE; // stay on last; could show completion
        alert('üéâ All 150 questions completed! You can Restart to practice again.');
        elNext.disabled = true;
      } else {
        renderBatch();
      }
    });

    elRestart.addEventListener('click', ()=>{
      batchStart = 0; mistakesByTopic = {}; accuracyHistory = []; updateByTopicChart(); updateAccuracyChart(); renderBatch();
    });

    // ---------------------------
    // Text-to-Speech (Web Speech API) ‚Äî read ONE question at a time; advance after answer
    // ---------------------------
    function speak(text){
      if(isMuted) return;
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      const voices = window.speechSynthesis.getVoices();
      const enIN = voices.find(v=>/en-?IN/i.test(v.lang));
      u.voice = enIN || voices.find(v=>/en-?GB|en-?US/i.test(v.lang)) || null;
      u.rate = 1.02; u.pitch = 1.0; u.volume = 1.0;
      window.speechSynthesis.speak(u);
    }

    function speakQuestionAt(idx){
      const batch = currentBatch();
      if(isMuted || idx < 0 || idx >= batch.length) return;
      const q = batch[idx];
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(`Question ${batchStart + idx + 1}. ${q.q}`);
      const voices = window.speechSynthesis.getVoices();
      const enIN = voices.find(v=>/en-?IN/i.test(v.lang));
      u.voice = enIN || voices.find(v=>/en-?GB|en-?US/i.test(v.lang)) || null;
      u.rate = 1.02; u.pitch = 1.0; u.volume = 1.0;
      window.speechSynthesis.speak(u);
    }

    function nextUnansweredIndex(){
      for(let i=0;i<answeredStates.length;i++) if(!answeredStates[i]) return i;
      return -1;
    }

    elMute.addEventListener('click',()=>{
      isMuted = !isMuted;
      elMute.textContent = isMuted ? 'üîá Voice: Off' : 'üîä Voice: On';
      elMute.setAttribute('aria-pressed', String(!isMuted));
      if(isMuted){ window.speechSynthesis.cancel(); }
      else { speakQuestionAt(currentVoiceIdxInBatch); }
    });

    elReplay.addEventListener('click',()=>{
      speakQuestionAt(currentVoiceIdxInBatch);
    });

    // ---------------------------
    // Charts
    // ---------------------------
    let byTopicChart, accuracyChart;
    function updateByTopicChart(){
      const ctx = document.getElementById('byTopic').getContext('2d');
      const labels = Object.keys(mistakesByTopic);
      const data = Object.values(mistakesByTopic);
      if(byTopicChart) byTopicChart.destroy();
      byTopicChart = new Chart(ctx, {type:'bar', data:{labels, datasets:[{label:'Mistakes', data, backgroundColor:'#4f79ff'}]}, options:{plugins:{legend:{display:false}}, scales:{y:{beginAtZero:true}}}});
    }
    function updateAccuracyChart(){
      const ctx = document.getElementById('accuracy').getContext('2d');
      if(accuracyChart) accuracyChart.destroy();
      accuracyChart = new Chart(ctx, {type:'line', data:{labels: accuracyHistory.map((_,i)=>`Attempt ${i+1}`), datasets:[{label:'Batch Accuracy %', data: accuracyHistory, borderColor:'#59f', tension:.25}]}, options:{scales:{y:{min:0,max:100}}}});
    }

    // boot
    renderBatch();
    updateByTopicChart();
    updateAccuracyChart();
  </script>
</body>
</html>
